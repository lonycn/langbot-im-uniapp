{"version":3,"file":"extensions.js","sources":["uni_modules/uni-im/sdk/methods/extensions.js"],"sourcesContent":["import $state from '../state/index.js';\nlet registeredExtensionPoints = {}// $state.ext._extensionPoints\n\n/**\n * 由扩展模块调用，在指定的扩展点上挂接一个扩展程序。\n * @param {String} extensionPointName 扩展点名称。\n * @param {Function|Object} ext 扩展实现，可以是一个 Function，也可以是一个包含 extension() 方法的 Object。\n */\nfunction installExt(extensionPointName, ext) {\n  registeredExtensionPoints[extensionPointName] = registeredExtensionPoints[extensionPointName] || []\n  registeredExtensionPoints[extensionPointName].push(ext)\n}\n\n/**\n * 检查在指定的扩展点上是否挂接了扩展程序。\n * @param {String} extensionPointName 扩展点名称。\n * @returns {boolean} true 表示安装了扩展程序。\n */\nfunction hasExt(extensionPointName) {\n  return registeredExtensionPoints[extensionPointName]\n      && registeredExtensionPoints[extensionPointName].length > 0\n}\n\n/**\n * 调用一个扩展点上挂接的所有扩展程序，按照挂接安装的顺序来调用。\n * \n * 入口参数和返回值都由调用方负责约定，此接口只负责透传。\n * \n * @param extensionPointName {String} 扩展点名称\n * @param args {any[]} 调用参数\n * @returns {any[]} 所有扩展程序的返回值按顺序组装在一个数组中返回。如果扩展点上挂接的扩展程序是异步函数，则返回值为相应的 Promise 对象。\n */\nfunction invokeExts(extensionPointName, ...args) {\n  if (!registeredExtensionPoints[extensionPointName]) return []\n  let results = []\n  for (let ext of registeredExtensionPoints[extensionPointName]) {\n    let result\n    if (typeof ext === 'function') {\n      result = ext.call(null, ...args)\n    } else if (typeof ext === 'object' && typeof ext.extension === 'function') {\n      result = ext.extension.call(ext, ...args)\n    }\n    results.push(result)\n  }\n  return results\n}\n\n/**\n * 扩展程序框架。\n * @module extensions\n */\nexport default {\n  installExt,\n  hasExt,\n  invokeExts,\n}\n\n// 目前已支持的扩展点如下：\n\n/**\n * 前端扩展点：更新未读消息总数。\n * @external ui-update-unread-count\n */\n\n/**\n * 前端扩展点：决定标题条是否要闪烁。\n * @external ui-flash-title-bar\n */\n\n/**\n * 前端扩展点：申请弹出消息通知的权限。\n * @external ui-notification-permission\n */\n\n/**\n * 前端扩展点：弹出的消息通知被用户点击。\n * @external ui-notification-clicked\n */\n\n/**\n * 前端扩展点：用户敲了 ESC 键。\n * @external ui-esc\n */\n\n/**\n * 前端扩展点：收到了新消息。\n * @external ui-new-message\n */\n\n/**\n * 前端扩展点：在会话列表中渲染每个会话时会调用此扩展点，扩展程序可以为该会话增加覆盖的图标元素。\n * @external conversation-avatar-overlay\n */\n\n/**\n * 前端扩展点：在会话列表中渲染每个群聊会话时会调用此扩展点，扩展程序可以为该会话增加 tag。\n * @external conversation-tags\n */\n\n/**\n * 前端扩展点：扩展程序可以注册一种新的消息类型，并提供相应的 hooks 执行处理逻辑。\n * @see MsgTypeOptions\n * @external msg-type-register\n */\n\n/**\n* 前端扩展点：在消息列表某条消息进入显示区时会调用此扩展点。\n* @external msg-appear\n*/\n\n/**\n* 前端扩展点：在消息列表某条消息离开显示区时会调用此扩展点。\n* @external msg-disappear\n*/\n\n/**\n* 前端扩展点：在渲染每条消息时会调用此扩展点，扩展程序可以返回扩展组件，为该消息增加一些显示元素。\n* @external msg-extra\n*/\n\n/**\n * 前端扩展点：扩展程序可以在 web-pc 端的消息输入框新增一个工具类的项。\n * @external input-msg-tool-bar\n */\n\n/**\n * @typedef MsgTypeOptions\n * @type {object}\n * @property {string} type - 消息类型。\n * @property {function} isReadable - 消息是否可见。\n * @property {function} [beforeLocalAdd] - 消息在本地保存之前的 hook 处理。\n */\n"],"names":[],"mappings":";;AACA,IAAI,4BAA4B,CAAE;AAOlC,SAAS,WAAW,oBAAoB,KAAK;AAC3C,4BAA0B,kBAAkB,IAAI,0BAA0B,kBAAkB,KAAK,CAAE;AACnG,4BAA0B,kBAAkB,EAAE,KAAK,GAAG;AACxD;AAOA,SAAS,OAAO,oBAAoB;AAClC,SAAO,0BAA0B,kBAAkB,KAC5C,0BAA0B,kBAAkB,EAAE,SAAS;AAChE;AAWA,SAAS,WAAW,uBAAuB,MAAM;AAC/C,MAAI,CAAC,0BAA0B,kBAAkB;AAAG,WAAO,CAAE;AAC7D,MAAI,UAAU,CAAE;AAChB,WAAS,OAAO,0BAA0B,kBAAkB,GAAG;AAC7D,QAAI;AACJ,QAAI,OAAO,QAAQ,YAAY;AAC7B,eAAS,IAAI,KAAK,MAAM,GAAG,IAAI;AAAA,IACrC,WAAe,OAAO,QAAQ,YAAY,OAAO,IAAI,cAAc,YAAY;AACzE,eAAS,IAAI,UAAU,KAAK,KAAK,GAAG,IAAI;AAAA,IACzC;AACD,YAAQ,KAAK,MAAM;AAAA,EACpB;AACD,SAAO;AACT;AAMA,MAAe,cAAA;AAAA,EACb;AAAA,EACA;AAAA,EACA;AACF;;"}