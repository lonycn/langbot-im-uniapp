{"version":3,"file":"langbot.ws.js","sources":["utils/langbot.ws.js"],"sourcesContent":["const DEFAULT_OPTIONS = {\n  url: '',\n  userId: '',\n  convId: 'c_langbot',\n  getAuthToken: () => '',\n  reconnect: true,\n  maxRetries: 6,\n  retryInterval: 1000,\n  onOpen: null,\n  onClose: null,\n  onError: null,\n  onStatusChange: null,\n};\n\nlet socket = null;\nlet listeners = new Set();\nlet connectionOptions = { ...DEFAULT_OPTIONS };\nlet reconnectAttempts = 0;\nlet reconnectTimer = null;\nlet manualClose = false;\n\nfunction notifyStatus(status) {\n  if (typeof connectionOptions.onStatusChange === 'function') {\n    try {\n      connectionOptions.onStatusChange(status);\n    } catch (error) {\n      console.error('[langbot.ws] onStatusChange callback error', error);\n    }\n  }\n}\n\nfunction buildInitPayload() {\n  const authToken = typeof connectionOptions.getAuthToken === 'function'\n    ? connectionOptions.getAuthToken()\n    : connectionOptions.getAuthToken;\n\n  const payload = {\n    type: 'init',\n    user_id: connectionOptions.userId,\n    conv_id: connectionOptions.convId,\n  };\n\n  if (authToken) {\n    payload.auth = { token: authToken };\n  }\n\n  return payload;\n}\n\nexport function configureWS(options = {}) {\n  connectionOptions = { ...connectionOptions, ...options };\n}\n\nexport function connectWS(options = {}) {\n  if (socket && typeof socket.readyState !== 'undefined' && socket.readyState !== 3) {\n    return;\n  }\n\n  connectionOptions = { ...connectionOptions, ...options };\n\n  if (!connectionOptions.url || !connectionOptions.userId) {\n    console.warn('[langbot.ws] url and userId must be provided before connecting.');\n    return;\n  }\n\n  manualClose = false;\n  clearReconnectTimer();\n  notifyStatus('connecting');\n\n  socket = uni.connectSocket({\n    url: connectionOptions.url,\n    complete: () => {},\n  });\n\n  socket.onOpen(() => {\n    reconnectAttempts = 0;\n    notifyStatus('connected');\n    socket.send({ data: JSON.stringify(buildInitPayload()) });\n    if (typeof connectionOptions.onOpen === 'function') {\n      try {\n        connectionOptions.onOpen();\n      } catch (error) {\n        console.error('[langbot.ws] onOpen callback error', error);\n      }\n    }\n  });\n\n  socket.onMessage((event) => {\n    let data = event.data;\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (error) {\n        console.warn('[langbot.ws] Failed to parse message', error);\n      }\n    }\n\n    listeners.forEach((fn) => {\n      try {\n        fn(data);\n      } catch (error) {\n        console.error('[langbot.ws] listener thrown error', error);\n      }\n    });\n  });\n\n  socket.onClose(() => {\n    socket = null;\n    notifyStatus(manualClose ? 'closed' : 'reconnecting');\n    if (typeof connectionOptions.onClose === 'function') {\n      try {\n        connectionOptions.onClose();\n      } catch (error) {\n        console.error('[langbot.ws] onClose callback error', error);\n      }\n    }\n    if (!manualClose && connectionOptions.reconnect) {\n      scheduleReconnect();\n    }\n  });\n\n  socket.onError((error) => {\n    notifyStatus('error');\n    if (typeof connectionOptions.onError === 'function') {\n      try {\n        connectionOptions.onError(error);\n      } catch (callbackError) {\n        console.error('[langbot.ws] onError callback error', callbackError);\n      }\n    }\n    if (socket) {\n      socket.close();\n    }\n  });\n}\n\nexport function onWSMessage(listener) {\n  if (typeof listener === 'function') {\n    listeners.add(listener);\n  }\n  return () => {\n    listeners.delete(listener);\n  };\n}\n\nexport function sendWSMessage(payload) {\n  if (!socket) {\n    console.warn('[langbot.ws] socket not connected, message dropped');\n    return;\n  }\n\n  const data = typeof payload === 'string' ? payload : JSON.stringify(payload);\n  socket.send({ data });\n}\n\nexport function closeWS() {\n  manualClose = true;\n  clearReconnectTimer();\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n}\n\nfunction scheduleReconnect() {\n  reconnectAttempts += 1;\n  if (reconnectAttempts > connectionOptions.maxRetries) {\n    console.warn('[langbot.ws] reached max reconnect attempts');\n    return;\n  }\n\n  const baseDelay = connectionOptions.retryInterval * Math.pow(2, reconnectAttempts - 1);\n  const jitter = Math.random() * baseDelay * 0.3;\n  const delay = Math.min(baseDelay + jitter, 30000);\n\n  clearReconnectTimer();\n  reconnectTimer = setTimeout(() => {\n    connectWS();\n  }, delay);\n}\n\nfunction clearReconnectTimer() {\n  if (reconnectTimer) {\n    clearTimeout(reconnectTimer);\n    reconnectTimer = null;\n  }\n}\n\nexport function isConnected() {\n  return !!socket;\n}\n"],"names":["uni"],"mappings":"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"}